# -*- encoding:utf-8 Mode: POLY-ORG;  -*- --- 
#+STARTUP: noindent

* Helper schemas

  Sometimes we'll want a schema to say that we accept any value at all:

  #+BEGIN_SRC clojure
    (defn anything? [x] true)
  #+END_SRC

* Objects and object id's

  Each object will be a map with a mandatory key =::kind= to tell the kind of
  object. We'll have four kinds of objects and so four possible values of the
  key:

  #+BEGIN_SRC clojure
    (s/def ::kind #{:world :system :component :entity})
  #+END_SRC

  Certain kinds of objects (all except world in fact) will have additional
  required keys. Some of them will serve to uniquely identify the particular
  object, others will contain additional data. An so we will use a sub-map of an
  object as its /identifier/, by keeping only the identifying keys (and
  =::kind= of course). We will not however exclude other keys from an identifier,
  so in fact every object will be its own valid identifier. Obviously, in practice,
  we'll want to use identifiers stripped down to minimum.

  To formalize the object identifiers we'll use a multi-schema:

  #+BEGIN_SRC clojure
    (defmulti id-spec ::kind)
    (s/def ::id (s/multi-spec id-spec ::kind))
  #+END_SRC

  So for every possible value of =::kind= we will provide an =id-spec= method
  defining required keys for an identifier of that particular kind of object.
  Thus the =::id= schema defines an object identifier of any kind.
  We will also define specific schemas for each kind.

  In the same way we'll define specs for objects themselves:

  #+BEGIN_SRC clojure
    (defmulti object-spec ::kind)
    (s/def ::object (s/multi-spec id-spec ::kind))
  #+END_SRC

* Component

*TODO*

  #+BEGIN_SRC clojure

    (s/def ::component (s/keys :req
                               [::kind ::entity-key ::component-key ::system-key ::component-type]))

    (s/def ::component-key keyword?)

    (defmethod object-spec :component [_] ::component)

    (s/def ::component-id (s/keys :req [::kind ::entity-key ::component-key]))
    (defmethod id-spec :component [_] ::component-id)

    (defn component [entity key system type]
      {::kind :component
       ::entity-key (entity-key entity)
       ::system-key (system-key system)
       ::type type
       ::component-key key})

    (defn component-id [entity key]
      {::kind :component
       ::entity-key (entity-key entity)
       ::component-key key})

    (defn component? [x]
      (= (::kind x) :component))

  #+END_SRC

* System

A system is also a very simple object: a system is identified by a system key
and a system object has no more mandatory content than a system id:

  #+BEGIN_SRC clojure
    (s/def ::system-key keyword?)
    (s/def ::system-id (s/and (s/keys :req [::kind ::system-key])
                              #(= :system (::kind %))))
    (defmethod id-spec :system [_] ::system-id)
    (s/def ::system ::system-id)
    (defmethod object-spec :system [_] ::system)
  #+END_SRC

A system doesn't hold its components: those are contained in entities and so
whenever a system would like to perform an operation on all of its components,
it must iterate over entities and their components (a component will have the key
of the system to which it belongs).

*TODO* - to nastepne:
  #+BEGIN_SRC clojure
    (defn system [key]
      {::kind :system
       ::system-key key})
    (s/fdef system
      :args (s/cat :key ::system-key)
      :ret (s/and ::system ::system-id ::id))

  #+END_SRC

*TODO* - a to nastepne? jak nie wszystko jeszcze bylo omowione (w szczegolnosci component)...

  #+BEGIN_SRC clojure


    (defn system-key [x]
      ;; x can be:
      ;; - system key itself (a keyword)
      ;; - a system id/object
      ;; - a component object
      (if (keyword? x) x (::system-key x)))
    (s/fdef system-key
      :args (s/cat :x (s/or :key ::system-key
                            :system (s/or :system ::system, :id ::system-id)
                            :component ::component))
      :ret ::system-key)

    (defn system-id [x]
      ;; x can be:
      ;; - system key
      ;; - a system id/object
      ;; - a component object
      (if (keyword? x)
        {::kind :system
         ::system-key x}
        (if (= (::kind x) :system)
          (to-id x)
          {::kind :system
           ::system-key (::system-key x)})))
    (s/fdef system-id
      :args (s/cat :x (s/or :key ::system-key
                            :system (s/or :system ::system, :id ::system-id)
                            :component ::component))
      :ret (s/and ::system-id ::id))

    (defn system-id? [x]
      (= (::kind x) :system))
    (s/fdef system-id?
      :args (s/cat :x anything?)
      :ret boolean?)

  #+END_SRC

* Entity
  
  *TODO*

  #+BEGIN_SRC clojure
    (s/def ::entity-key (s/or :keyword keyword? :number number?))
    (s/def ::entity-type keyword?)
    (s/def ::entity-id (s/keys :req [::kind ::entity-key]))
    (defmethod id-spec :entity [_] ::entity-id)
    (s/def ::entity (s/keys :req [::kind ::entity-key ::entity-type]))
    (defmethod object-spec :entity [_] ::entity)
  #+END_SRC

  #+BEGIN_SRC clojure

    (defn entity [key type]
      {::kind :entity
       ::entity-type type
       ::entity-key key
       ::components {}})
    (s/fdef entity
      :args (s/cat :key ::entity-key, :type ::entity-type)
      :ret ::entity)

    (defn entity-id [x]
      ;; x can be:
      ;; - entity key
      ;; - an entity id/object
      ;; - a component id/object
      (if (keyword? x)
        {::kind :entity
         ::entity-key x}
        (if (= (::kind x) :entity)
          (to-id x)
          {::kind :entity
           ::entity-key (::entity-key x)})))
    (s/fdef entity-id
      :args (s/cat :x (s/or :key ::entity-key
                            :entity ::entity
                            :entity-id ::entity-id
                            :component ::component
                            :component-id ::component-id))
      :ret ::entity-id)

    (defn entity-id? [x]
      (= (::kind x) :entity))
    (s/fdef entity-id?
      :args (s/cat :x anything?)
      :ret boolean?)

    (defn entity-key [x]
      ;; x can be:
      ;; - entity key itself (a keyword)
      ;; - an entity id/object
      ;; - a component id/object
      (if (keyword? x) x (::entity-key x)))
    (s/fdef entity-key
      :args (s/cat :x (s/or :key ::entity-key
                            :entity ::entity
                            :entity-id ::entity-id
                            :component ::component
                            :component-id ::component-id))
      :ret ::entity-key)

  #+END_SRC
  
* World

  There can be only one world, so to identify the world we only need to provide
  the =::kind=, so here's a schema for the world id and the world portion of the
  =::id= schema:

  #+BEGIN_SRC clojure
    (s/def ::world-id (s/and (s/keys :req [::kind]) #(= :world (::kind %))))
    (defmethod id-spec :world [_] ::world-id)
  #+END_SRC

  Here are schemas for the world object:

  #+BEGIN_SRC clojure
    (s/def ::world
      (s/and
       (s/keys :req [::kind ::entities ::systems ::time ::event-queue])
       #(= :world (::kind %))))

    (defmethod object-spec :world [_] ::world)
  #+END_SRC

  As we could see above, a world object holds everything:

  the map of entities (which will contain components):

  #+BEGIN_SRC clojure
  (s/def ::entities (s/map-of ::entity-key ::entity))
  #+END_SRC

  the map of systems:

  #+BEGIN_SRC clojure
  (s/def ::systems (s/map-of ::system-key ::system))
  #+END_SRC

  current time:

  #+BEGIN_SRC clojure
  (s/def ::time integer?)
  #+END_SRC

  and an event queue (TODO: spec in that module).

  Here's a function to create a new, empty world object:

  #+BEGIN_SRC clojure

    (defn world []
      {::kind :world
       ::entities {}
       ::systems {}
       ::time 0
       ::event-queue (eq/create)})
    (s/fdef world
      :args (s/cat)
      :ret (s/and ::world ::world-id ::id))

  #+END_SRC

  and functions to create the world id and to check if a given value (any value)
  is a world id or not:

  #+BEGIN_SRC clojure
    (defn world-id [] {::kind :world})
    (s/fdef world-id :args (s/cat) :ret (s/and ::world-id ::id))

    (defn world-id? [x] (= (::kind x) :world))
    (s/fdef world-id? :args (s/cat :x anything?) :ret (s/and boolean?))

  #+END_SRC

* Inne

  #+BEGIN_SRC clojure

    ;; NOTE. The `id?` predicate is very simple, as it only checks for the presence of the ::kind attribute.
    ;; We assume that if the API is properly used and no external code manually creates maps with
    ;; keys in our namespace, then that check is sufficient to ensure that we have an object or id created by us.
    ;; If a user wants a full check, they can use spec directly: (s/valid? ::id x) or (s/valid? ::object x).
    (defn id? [x]
      (boolean (::kind x)))
    (s/fdef id?
      :args (s/cat :x anything?)
      :ret boolean?)

  #+END_SRC

  Each object is its own id, but not vice-versa.

  #+BEGIN_SRC clojure

    (defn to-id [object]
      (if (= (::kind object) :component)
        (select-keys object [::kind ::entity-key ::component-key])
        (select-keys object [::kind ::system-key ::entity-key ::component-key])))
    (s/fdef to-id
      :args (s/cat :object ::id)
      :ret ::id)

  #+END_SRC



* Cheat-sheet?


  #+BEGIN_SRC clojure :load no

  ;*** Objects *************************************************************

  ;;; World ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  #_schemas:      ::world-id ::world
  #_constructors: (world-id) (world)
  #_predicates:   (world-id? <any>)
  ;;; System ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Component ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; Entity ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  #_schemas:      ::system-key ::system-id ::system
  #_constructors: (system-id <system key>) (system <system-key>)
  #_predicates:   (system-id? <any>)
  #_extractors:   (system-key <system-key>|<system-id>|<system>|<component>)
                  (system-id  <system-key>|<system-id>|<system>|<component>)

  ;*** Querying ************************************************************

  ; e.g. (all-systems <world>)

  ;*** Modifying ***********************************************************

  ; e.g. (remove-entity ...)

  ;*** Events **************************************************************

  #+END_SRC

